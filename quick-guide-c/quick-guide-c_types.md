

## Типы данных<a name="types"></a>
Каждый тип в C является либо объектным, либо функциональным.
### Логический тип
Предпочтительнее для использования вариант с типом `bool`.
```c
_Bool flag1 = 0;
```
```c
#include <stdbool.h>
bool flag2 = false;
```
### Численные типы
#### Целочисленные типы

#### Перечисляемые типы
```c
enum day { sun, mon, tue, wed, thu, fri, sat };
enum cardinal_points { north = 0, east = 90, south = 180, west = 270 };
enum months { jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };
```

#### Типы с плавающей запятой

### Производные типы
Производными называют типы, основанные на других типах. В их число входят указатели, массивы, определения типов, структуры и объединения.

#### Указатели <a name="pointers"></a>
Кроме того, в C есть указатели, которые можно считать адресами — областями памяти, в которых хранятся объекты или функции. Тип указателя, основанный на типе функции или объекта, называется ссылочным типом. Указатель, имеющий ссылочный тип T, называют указателем на T.
Объекты и функции — это разные вещи, и потому объектные указатели отличаются от функциональных и их нельзя использовать как взаимозаменяемые.  

В объявлении или определении функции операция `*` выступает частью объявления указателя, сигнализируя о том, что параметр является указателем на объект или функцию заданного типа.  

`*` — унарная операция косвенного обращения (разыменовывания);  
`&` — унарная операция для взятия адреса, она генерирует указатель на свой операнд.  

```c
void swap(int *a, int *b) {
    int t = *pa;
    *pa = *pb;
    *pb = t;
    return;
}
```
Вызов функции:
```c
swap(&a, &b);
```

### Квалификаторы типов
Тип можно сделать квалифицированным за счет использования одного или нескольких квалификаторов, таких как `const`, `volatile` и `restrict`. Каждый квалификатор влияет на поведение кода при обращении к объектам квалифицированного типа. Квалифицированная и неквалифицированная версии типа являются взаимозаменяемыми в случае использования в качестве аргументов функций, возвращаемых значений и членов объединений.  

#### `_Atomic`
Квалификатор типа `_Atomic`, появившийся в C11, предоставляет поддержку конкурентного выполнения.

#### `const`
Объекты, объявленные с использованием квалификатора `const` (const-квалифицированные объекты), не подлежат изменению. После инициализации им больше нельзя присваивать значения. Это значит, что компилятор может разместить их в памяти, доступной только для чтения, и любая попытка записи в них приведет к ошибке времени выполнения.

#### `restrict`
Используется с указателями для поддержки оптимизации. Объекты, к которым обращаются косвенно через указатели, зачастую не удается оптимизировать должным образом из-за того, что на один и тот же объект теоретически могут ссылаться сразу несколько указателей. Это может затруднить оптимизацию, поскольку компилятор не знает, может ли модификация одного объекта привести к частичному изменению другого, который с виду никак с ним не связан.

#### `volatile`
Объекты volatile-квалифицированных типов имеют специальное назначение. Статические объекты с квалификатором volatile используются для представления портов ввода/вывода, отображенных в память, а статические объекты сразу с двумя квалификаторами, const и volatile, могут представлять порты ввода, отображенные в память, такие как часы реального времени.
Значения, хранящиеся в этих объектах, могут изменяться без ведома компилятора. Например, значение часов реального времени может меняться при каждом обращении, даже если сама программа это значение не меняет. Использование volatile-квалифицированного типа сообщает компилятору о том, что значение может измениться, и гарантирует, что код будет каждый раз обращаться к часам реального времени (в противном случае эти обращения могут быть удалены в ходе оптимизации или заменены уже считанным и закэшированным значением). 
